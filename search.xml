<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>RRS存档</title>
      <link href="posts/5cf5b17a/"/>
      <url>posts/5cf5b17a/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> RSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>服务器踩坑记录</title>
      <link href="posts/cb24ed77/"/>
      <url>posts/cb24ed77/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CS61B-lecture10,11</title>
      <link href="posts/3b49ac76/"/>
      <url>posts/3b49ac76/</url>
      
        <content type="html"><![CDATA[<h1 id="Comparison"><a href="#Comparison" class="headerlink" title="Comparison"></a>Comparison</h1><h2 id="General-Maximization-Function-Through-Inheritance"><a href="#General-Maximization-Function-Through-Inheritance" class="headerlink" title="General Maximization Function Through Inheritance"></a>General Maximization Function Through Inheritance</h2><h3 id="OurComparable接口"><a href="#OurComparable接口" class="headerlink" title="OurComparable接口"></a>OurComparable接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public interface OurComparable &#123;</span><br><span class="line">   int compareTo(Object obj);</span><br><span class="line">&#125;     </span><br><span class="line">public class Dog implements OurComparable &#123;</span><br><span class="line">public int compareTo(Object obj) &#123;</span><br><span class="line">    &#x2F;** Warning, cast can cause runtime error! *&#x2F;</span><br><span class="line">       Dog uddaDog &#x3D; (Dog) obj;</span><br><span class="line">       return this.size - uddaDog.size;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Maximizer &#123;</span><br><span class="line">public static OurComparable max(OurComparable[] a) &#123;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Dog[] dogs &#x3D; new Dog[]&#123;d1, d2, d3&#125;;</span><br><span class="line">Dog largest &#x3D; (Dog) Maximizer.max(dogs);</span><br></pre></td></tr></table></figure><h4 id="Benefits-of-this-approach"><a href="#Benefits-of-this-approach" class="headerlink" title="Benefits of this approach"></a>Benefits of this approach</h4><ul><li>No need for array maximization code in every custom type (i.e. no Dog.maxDog(Dog[]) function required).</li><li>Code that operates on multiple types (mostly) gracefully, e.g.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OurComparable[] objs &#x3D; getItems(“somefile.txt”); </span><br><span class="line">return Maximizer.max(objs);</span><br></pre></td></tr></table></figure></li></ul><h4 id="two-issues"><a href="#two-issues" class="headerlink" title="two issues"></a>two issues</h4><ul><li>Awkward casting to/from Objects.</li><li>We made it up.<ul><li>No existing classes implement OurComparable (e.g. String, etc).</li><li>No existing classes use OurComparable (e.g. no built-in max function that uses OurComparable)</li></ul></li></ul><h3 id="Comparable接口"><a href="#Comparable接口" class="headerlink" title="Comparable接口"></a>Comparable接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface Comparable&lt;T&gt; &#123;</span><br><span class="line">     public int compareTo(T obj);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">public class Dog implements Comparable&lt;Dog&gt; &#123;</span><br><span class="line">public int compareTo(Dog uddaDog) &#123;</span><br><span class="line">    return this.size - uddaDog.size;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Ourcomparable 代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface OurComparable &#123;</span><br><span class="line">   int compareTo(Object obj);</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h4 id="Comparable-Advantages"><a href="#Comparable-Advantages" class="headerlink" title="Comparable Advantages"></a>Comparable Advantages</h4><ul><li>Lots of built in classes implement Comparable (e.g. String).</li><li>Lots of libraries use the Comparable interface (e.g. Arrays.sort)</li><li>Avoids need for casts.</li></ul><h3 id="Comparators"><a href="#Comparators" class="headerlink" title="Comparators"></a>Comparators</h3><h4 id="Natural-Order"><a href="#Natural-Order" class="headerlink" title="Natural Order"></a>Natural Order</h4><ul><li>数字大小排列</li><li>按名称排列</li></ul><h4 id="Compartor接口"><a href="#Compartor接口" class="headerlink" title="Compartor接口"></a>Compartor接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Comparator&lt;T&gt; &#123;</span><br><span class="line">int compare(T o1, T o2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接口实现与使用"><a href="#接口实现与使用" class="headerlink" title="接口实现与使用"></a>接口实现与使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Dog implements Comparable&lt;Dog&gt; &#123;</span><br><span class="line">  private String name;</span><br><span class="line">  private int size;</span><br><span class="line"></span><br><span class="line">  public static class NameComparator implements Comparator&lt;Dog&gt; &#123;</span><br><span class="line">public int compare(Dog d1, Dog d2) &#123;</span><br><span class="line">    return d1.name.compareTo(d2.name);</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">\\使用</span><br><span class="line">Comparator&lt;Dog&gt; cd &#x3D; new Dog.NameComparator();</span><br><span class="line">if (cd.compare(d1, d3) &gt; 0) &#123;</span><br><span class="line">    d1.bark();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    d3.bark();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="以上接口的总结"><a href="#以上接口的总结" class="headerlink" title="以上接口的总结"></a>以上接口的总结</h2><ul><li>Sometimes a function needs the help of another function that might not have been written yet.<ul><li>Example: max needs compareTo</li><li>The helping function is sometimes called a “callback”. </li></ul></li><li>Some languages handle this using explicit function passing.</li><li>In Java, we do this by wrapping up the needed function in an interface (e.g. Arrays.sort needs compare which lives inside the comparator interface)</li><li>Arrays.sort “calls back” whenever it needs a comparison.<ul><li>Similar to giving your number to someone if they need information.</li><li>See Project 1B to explore how to write code that uses comparators.</li></ul></li></ul><h2 id="关于静态类的想法"><a href="#关于静态类的想法" class="headerlink" title="关于静态类的想法"></a>关于静态类的想法</h2><p><em><strong>猜想：</strong></em> 静态类能被用来调用其中的静态方法（对parameter进行计算） </p><h1 id="Java-libraries"><a href="#Java-libraries" class="headerlink" title="Java libraries"></a>Java libraries</h1><h2 id="接口的另外两个好处："><a href="#接口的另外两个好处：" class="headerlink" title="接口的另外两个好处："></a>接口的另外两个好处：</h2><ul><li>提供一个供许多类共有的方法</li><li>提供一个通用方法 例：<code>compartor</code></li></ul><h2 id="Abstract-Data-Types-抽象数据类型"><a href="#Abstract-Data-Types-抽象数据类型" class="headerlink" title="Abstract Data Types(抽象数据类型)"></a>Abstract Data Types(抽象数据类型)</h2><p>我的理解：我是一个有需求的ADT，需要实现我的方法，而这些方法有多种方式可以实现</p><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p>collection interface以及继承它的interface是java.util library 中最重要的几个接口</p><p>继承了collection接口的三个接口：</p><ul><li>Lists of things.</li><li>Sets of things.</li><li>Mappings between items, e.g. jhug’s grade is 88.4.<br>Maps also known as associative arrays, associative lists (in Lisp), symbol tables, dictionaries (in Python).</li></ul><h2 id="java-util-package"><a href="#java-util-package" class="headerlink" title="java.util package"></a>java.util package</h2><p>在这个包中有接口和我们可以用的具体类</p><h2 id="3-tasks-given-the-text-of-a-book"><a href="#3-tasks-given-the-text-of-a-book" class="headerlink" title="3 tasks, given the text of a book"></a>3 tasks, given the text of a book</h2><h3 id="Count-the-number-of-unique-words"><a href="#Count-the-number-of-unique-words" class="headerlink" title="Count the number of unique words."></a>Count the number of unique words.</h3><p><strong>Example: Using a Set to Count Unique Words</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static int countUniqueWords(List&lt;String&gt; words) &#123;</span><br><span class="line">Set&lt;String&gt; ss &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">for (String s : words) &#123;</span><br><span class="line">       ss.add(s);    </span><br><span class="line">&#125;</span><br><span class="line">return ss.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static int countUniqueWords(List&lt;String&gt; words) &#123;</span><br><span class="line">Set&lt;String&gt; ss &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">ss.addAll(words);</span><br><span class="line">return ss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Example: Using a Map to Create Counts of Specific Words</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static Map&lt;String, Integer&gt; </span><br><span class="line">        collectWordCount(List&lt;String&gt; words, List&lt;String&gt; targets) &#123;</span><br><span class="line">Map&lt;String, Integer&gt; wordCounts &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">for (String s : targets) &#123;</span><br><span class="line">       wordCounts.put(s, 0);</span><br><span class="line">&#125;</span><br><span class="line">for (String s : words) &#123;</span><br><span class="line">       if (wordCounts.containsKey(s)) &#123;</span><br><span class="line">          int oldCount &#x3D; wordCounts.get(s);</span><br><span class="line">         wordCounts.put(s, oldCount + 1);</span><br><span class="line">       &#125;      </span><br><span class="line">&#125;</span><br><span class="line">return wordCounts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口的实现方式有多种选择"><a href="#接口的实现方式有多种选择" class="headerlink" title="接口的实现方式有多种选择"></a>接口的实现方式有多种选择</h3><p>Allows power user to explicitly handle engineering tradeoffs.</p><h1 id="Interfaces"><a href="#Interfaces" class="headerlink" title="Interfaces"></a>Interfaces</h1><h2 id="Inheritance-Summary-So-Far"><a href="#Inheritance-Summary-So-Far" class="headerlink" title="Inheritance Summary (So Far)"></a>Inheritance Summary (So Far)</h2><ul><li>Interface inheritance: What (the class can do).</li><li>Implementation inheritance: How (the class does it).</li></ul><p><strong>Interfaces may combine a mix of abstract and default methods.</strong></p><ul><li>Abstract methods are what. And must be overridden by subclass.</li><li>Default methods are how.</li></ul><h2 id="其他要注意的"><a href="#其他要注意的" class="headerlink" title="其他要注意的"></a>其他要注意的</h2><ul><li>Unless you use the keyword default, a method will be abstract.</li><li>Unless you specify an access modifier, a method will be public.</li><li>Can provide variables, but they are public static final.<ul><li>final means the value can never change. Use for constants: G=6.67e-11</li></ul></li><li>A class can implement multiple interfaces.</li></ul><h2 id="Interface-Summary"><a href="#Interface-Summary" class="headerlink" title="Interface Summary"></a>Interface Summary</h2><ul><li>不能被实例化</li><li>Can provide either abstract or concrete methods.<ul><li>Use no keyword for abstract methods.</li><li>Use default keyword for concrete methods.</li></ul></li><li>Can provide only public static final variables. 变量无法更改</li></ul><h1 id="Abstract-Classes"><a href="#Abstract-Classes" class="headerlink" title="Abstract Classes"></a>Abstract Classes</h1><h2 id="Abstract-classes"><a href="#Abstract-classes" class="headerlink" title="Abstract classes"></a>Abstract classes</h2><ul><li>不能被实例化</li><li>与接口相反，抽象方法需要使用<code>abstract</code>来标注</li><li>可以有任何类型的变量</li><li>Can provide protected and package private methods [after mt1].（我对mt1的理解是在第一个方法之后）</li></ul><h2 id="通常用法"><a href="#通常用法" class="headerlink" title="通常用法"></a>通常用法</h2><p>为接口的实现提供基础</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractList61B&lt;T&gt; implements List61B&lt;T&gt; &#123;</span><br><span class="line">int size &#x3D; 0;</span><br><span class="line"> public AbstractList61B() &#123; size &#x3D; 0; &#125;</span><br><span class="line"> @Override</span><br><span class="line">public int size() &#123;</span><br><span class="line">    return size;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class AList&lt;T&gt; extends AbstractList61B&lt;T&gt; &#123; ... &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="好处和坏处"><a href="#好处和坏处" class="headerlink" title="好处和坏处"></a>好处和坏处</h2><h3 id="Good"><a href="#Good" class="headerlink" title="Good"></a>Good</h3><p>Avoids the need to write a size() method or declare a size variable in AList and SLList.</p><h3 id="Bad"><a href="#Bad" class="headerlink" title="Bad"></a>Bad</h3><p>混淆结构 (e.g. maybe you don’t want a size variable).</p><h1 id="Summary-Abstract-Classes-vs-Interfaces"><a href="#Summary-Abstract-Classes-vs-Interfaces" class="headerlink" title="Summary: Abstract Classes vs. Interfaces"></a>Summary: Abstract Classes vs. Interfaces</h1><h2 id="Interfaces-1"><a href="#Interfaces-1" class="headerlink" title="Interfaces"></a>Interfaces</h2><ul><li>Primarily for interface inheritance. Limited implementation inheritance.</li><li>Classes can implement multiple interfaces.</li></ul><h2 id="Abstract-classes-1"><a href="#Abstract-classes-1" class="headerlink" title="Abstract classes"></a>Abstract classes</h2><ul><li>Can do anything an interface can do, and more.</li><li>Subclasses only extend one abstract class.</li></ul><h1 id="An-example-for-abstract-class"><a href="#An-example-for-abstract-class" class="headerlink" title="An example for abstract class"></a>An example for abstract class</h1><ul><li>AbstractList provides default implementations for methods.</li><li>Why not just put them in List itself? No default methods in Java interfaces until 2014, and the AbstractList was public so can’t just throw it away.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractList&lt;E&gt;</span><br><span class="line">   implements List&lt;E&gt; &#123;</span><br><span class="line"> </span><br><span class="line"> ...</span><br><span class="line"> </span><br><span class="line">   public boolean add(E e) &#123;</span><br><span class="line">       add(size(), e);</span><br><span class="line">    return true;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Packages"><a href="#Packages" class="headerlink" title="Packages"></a>Packages</h1><p>To address the fact that classes might share names:</p><ul><li>A package is a namespace that organizes classes and interfaces.</li><li>Naming convention: Package name starts with website address (backwards). </li></ul><p><em><strong>注意：</strong></em> 我们不用遵循第二条因为我们不会distribution代码</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="包外"><a href="#包外" class="headerlink" title="包外"></a>包外</h3><p>加上包名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">\\Dog.java</span><br><span class="line">package ug.joshh.animal;</span><br><span class="line"> </span><br><span class="line">public class Dog &#123;</span><br><span class="line">private String name;</span><br><span class="line">private String breed;</span><br><span class="line">private double size;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\\e.g. 1</span><br><span class="line">ug.joshh.animal.Dog d &#x3D; </span><br><span class="line">    new ug.joshh.animal.Dog(...);</span><br><span class="line">\\e.g. 2</span><br><span class="line">org.junit.Assert.assertEquals(5, 5); </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="包内"><a href="#包内" class="headerlink" title="包内"></a>包内</h3><p>If used from another class in same package (e.g. ug.joshh.animal.DogLauncher), can just use simple name.</p><h2 id="import-class"><a href="#import-class" class="headerlink" title="import class"></a>import class</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import ug.joshh.animal.Dog;</span><br><span class="line">Dog d &#x3D; new Dog(...); </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="import-多个class"><a href="#import-多个class" class="headerlink" title="import 多个class"></a>import 多个class</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import ug.joshh.animal.*;</span><br><span class="line">Dog d &#x3D; new Dog(...); </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="import-static"><a href="#import-static" class="headerlink" title="import static"></a>import static</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import static org.junit.Assert.assertEquals;</span><br><span class="line">assertEquals(5, 5); </span><br></pre></td></tr></table></figure><p><em><strong>Dangerous! Will cause compilation error if another <code>*</code> imported class contains Dog.</strong></em></p><h1 id="命令行使用"><a href="#命令行使用" class="headerlink" title="命令行使用"></a>命令行使用</h1><p>跳过，有空看</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CS61B-lecture7，8，9</title>
      <link href="posts/4d0299b9/"/>
      <url>posts/4d0299b9/</url>
      
        <content type="html"><![CDATA[<h1 id="Interface-Inheritance"><a href="#Interface-Inheritance" class="headerlink" title="Interface Inheritance"></a>Interface Inheritance</h1><h2 id="子类和父类的构造器"><a href="#子类和父类的构造器" class="headerlink" title="子类和父类的构造器"></a>子类和父类的构造器</h2><p><img src= "/img/loading.gif" data-lazy-src="https://s1.ax1x.com/2020/07/28/aViADe.png" alt="aViADe.png"></p><h2 id="Super"><a href="#Super" class="headerlink" title="Super();"></a>Super();</h2><ul><li><p>当使用了子类的构造器时，会自动加入一行代码<code>super();</code>表示使用了父类的构造器</p></li><li><p>Use super to invoke overridden superclass methods and constructors.(使用super来调用父类被override的方法)</p></li></ul><h1 id="implements和extends"><a href="#implements和extends" class="headerlink" title="implements和extends"></a>implements和extends</h1><h2 id="父类和子类"><a href="#父类和子类" class="headerlink" title="父类和子类"></a>父类和子类</h2><p>implements和extends 代表了父类和子类的关系，子类继承父类所有的签名</p><p>如果子类要继承方法，需要用default标明</p><p><strong>子类需要override所用方法并用 ·@override· 标明</strong><br>原因是可能有些时候两个方法不满足override条件，需要这行代码来检查</p><p>子类对象确实拥有父类对象中所有的属性和方法，但是父类对象中的私有属性和方法，子类是无法访问到的，只是拥有，但不能使用。</p><p>当子类覆盖父类的成员变量时，父类方法使用的是父类的成员变量，子类方法使用的是子类的成员变量</p><ul><li>子类覆盖父类的方法，必须有同样的参数返回类型，否则编译不能通过</li><li>子类覆盖父类的方法，在jdk1.5后，参数返回类可以是父类方法返回类的子类</li><li>子类覆盖父类方法，可以修改方法作用域修饰符，但只能把方法的作用域放大，而不能把public修改为private</li><li>子类方法能够访问父类的protected作用域成员，不能够访问默认的作用域成员,除非子类与父类同包</li><li>子类的静态方法不能隐藏同名的父类实例方法</li></ul><p><em><strong>注意：</strong></em> 子类不能直接访问父类的私有属性，子类只能在父类中写一个public的getXXX的方法来获取父类中的private属性，子类就调用父类的getXXX来获取private属性</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>父类中的公有方法和域(属性)，在类继承中将会被子类继承，但是私有的将不能被继承。</p><h2 id="extends和implements的区别"><a href="#extends和implements的区别" class="headerlink" title="extends和implements的区别"></a>extends和implements的区别</h2><p>When a class is a hyponym of an interface, we used implements.<br>Example: SLList<Blorp> implements List61B<Blorp></p><p>If you want one class to be a hyponym of another class, you use extends.</p><ul><li>extends是继承父类，只要那个类不是声明为final或者那个类定义为abstract的就能继承，</li><li>JAVA中不支持多重继承，但是可以用接口来实现，这样就要用到implements，</li><li>继承只能继承一个类，但implements可以实现多个接口，用逗号分开就行了 ,<br>   比如  <code>class A extends B implementsC,D,E   </code></li></ul><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>对于class而言，extends用于（单）继承一个类（class），而implements用于实现一个接口（interface）。  </p><p>interface的引入是为了部分地提供多继承的功能。在interface中只需声明方法头，而将方法体留给实现的class来做。这些实现的class的实例完全可以当作interface的实例来对待。在interface之间也可以声明为extends（多继承）的关系。</p><p>注意:一个interface可以extends多个其他interface。</p><h1 id="Casting"><a href="#Casting" class="headerlink" title="Casting"></a>Casting</h1><p>以下代码用了casting可以编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Poodle frank  &#x3D; new Poodle(&quot;Frank&quot;, 5);</span><br><span class="line">Poodle frankJr &#x3D; new Poodle(&quot;Frank Jr.&quot;, 15);</span><br><span class="line">Dog largerDog &#x3D; maxDog(frank, frankJr);</span><br><span class="line">Poodle largerPoodle &#x3D; (Poodle) maxDog(frank, frankJr);</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>casting使得编译器可以将动态类型为父类表示为它的子类，但是在使用子类的方法时可能会报错</li><li>casting不会改变参数类型</li></ul><h1 id="Dynamic-Method-Selection"><a href="#Dynamic-Method-Selection" class="headerlink" title="Dynamic Method Selection"></a>Dynamic Method Selection</h1><h2 id="在使用override时"><a href="#在使用override时" class="headerlink" title="在使用override时"></a>在使用override时</h2><p>决定最终方法使用的是<code>dynamic type</code>，也叫<code>run-time type</code> 与次相对应的还有<code>static type</code>，也叫<code>compile-time type</code></p><h2 id="在使用overload时"><a href="#在使用overload时" class="headerlink" title="在使用overload时"></a>在使用overload时</h2><p>根据参数静态类型来决定方法调用，当找不到时会找一个近似的，实在没有会报错</p><h2 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h2><ul><li><p>overload的优先级在override之上</p></li><li><p>Remember: The compiler chooses the most specific matching method signature from the static type of the invoking class.（override调用规则）</p></li></ul><h1 id="JUnit"><a href="#JUnit" class="headerlink" title="JUnit"></a>JUnit</h1><p><img src= "/img/loading.gif" data-lazy-src="https://s1.ax1x.com/2020/07/28/aEvnVx.png" alt="aEvnVx.png"></p><h2 id="New-Syntax-1"><a href="#New-Syntax-1" class="headerlink" title="New Syntax #1:"></a>New Syntax #1:</h2><p><code>assertEquals(expected, actual);</code></p><ul><li>Tests that expected equals actual.</li><li>If not, program terminates with verbose message.</li><li>Other methods like <code>assertEquals</code> include <code>assertFalse</code>, <code>assertNotNull</code>, etc., see <a href="http://junit.org/junit4/javadoc/4.12/org/junit/Assert.html">http://junit.org/junit4/javadoc/4.12/org/junit/Assert.html</a></li></ul><h2 id="在使用JUnit时import"><a href="#在使用JUnit时import" class="headerlink" title="在使用JUnit时import"></a>在使用JUnit时import</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import org.junit.Test;</span><br><span class="line">import static org.junit.Assert.*;</span><br></pre></td></tr></table></figure><h2 id="JUnittest-格式："><a href="#JUnittest-格式：" class="headerlink" title="JUnittest 格式："></a>JUnittest 格式：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testSort() &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Higher-Order-Function"><a href="#Higher-Order-Function" class="headerlink" title="Higher Order Function"></a>Higher Order Function</h1><p>A function that treats another function as data.</p><h2 id="Example-in-Python"><a href="#Example-in-Python" class="headerlink" title="Example in Python"></a>Example in Python</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def tenX(x):</span><br><span class="line">return 10*x</span><br><span class="line"> </span><br><span class="line">def do_twice(f, x):</span><br><span class="line">return f(f(x))</span><br><span class="line"> </span><br><span class="line">print(do_twice(tenX, 2)) </span><br></pre></td></tr></table></figure><h2 id="Same-in-java"><a href="#Same-in-java" class="headerlink" title="Same in java"></a>Same in java</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public interface IntUnaryFunction &#123;</span><br><span class="line">int apply(int x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TenX implements IntUnaryFunction &#123;</span><br><span class="line">public int apply(int x) &#123;</span><br><span class="line">   return 10 * x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class HoFDemo &#123;</span><br><span class="line">public static int do_twice(IntUnaryFunction f, int x) &#123;</span><br><span class="line">   return f.apply(f.apply(x));</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">   System.out.println(do_twice(new TenX(), 2));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CS51B-lecture1-6</title>
      <link href="posts/95736992/"/>
      <url>posts/95736992/</url>
      
        <content type="html"><![CDATA[<h1 id="课程大纲"><a href="#课程大纲" class="headerlink" title="课程大纲"></a>课程大纲</h1><h2 id="Phase-1-Programming-Intensive-Introduction-to-Java"><a href="#Phase-1-Programming-Intensive-Introduction-to-Java" class="headerlink" title="Phase 1: Programming Intensive Introduction to Java."></a>Phase 1: Programming Intensive Introduction to Java.</h2><p>Weeks 1-4.<br>One browser-based programming HW (this HW0 is optional).<br>Three labs to introduce you to various tools (starting this week).<br>Two projects (proj0 and proj1).</p><h2 id="Phase-2-Advanced-Programming"><a href="#Phase-2-Advanced-Programming" class="headerlink" title="Phase 2: Advanced Programming"></a>Phase 2: Advanced Programming</h2><p>Weeks 5-7.<br>One small HW (HW1).<br>One large project, due ~3/5.<br>New: You design your own explorable world (within some constraints).<br>Labs to support large project.</p><h2 id="Phase-3-Data-Structures-and-Algorithms"><a href="#Phase-3-Data-Structures-and-Algorithms" class="headerlink" title="Phase 3: Data Structures and Algorithms"></a>Phase 3: Data Structures and Algorithms</h2><p>Weeks 8-14<br>Incredibly important and foundational material: Expect an CS job interview to lean heavily on this part of the course.<br>Labs: Implement a data structure or algorithm.<br>Each lab ends with a TA led discussion of best implementation.<br>Six HWs: Apply a data structure or algorithm toward a real world problem.<br>Two released during RRR week. Can be used to makeup missed homeworks earlier, or for practice.<br>One very challenging data structure/algorithms project (but not as big as project 2).</p><p>See calendar at <a href="http://datastructur.es/">http://datastructur.es</a> for more.</p><h1 id="static-和-non-static"><a href="#static-和-non-static" class="headerlink" title="static 和 non-static"></a>static 和 non-static</h1><h2 id="静态和实例方法："><a href="#静态和实例方法：" class="headerlink" title="静态和实例方法："></a>静态和实例方法：</h2><p><strong>静态方法只能使用静态变量，同时可以直接通过类名来调动（不推荐通过对象）<br>  实例方法可以调动实例变量，同时只能通过对象来调动</strong></p><h2 id="静态和实例变量："><a href="#静态和实例变量：" class="headerlink" title="静态和实例变量："></a>静态和实例变量：</h2><p><strong>静态变量为所有该类的对象共用，实例变量不会互相影响</strong></p><h2 id="static-和-non-static混合调用"><a href="#static-和-non-static混合调用" class="headerlink" title="static 和 non-static混合调用"></a>static 和 non-static混合调用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static Dog maxDog(Dog d1, Dog d2) &#123;</span><br><span class="line">if (d1.weightInPounds &gt; d2.weightInPounds) &#123;</span><br><span class="line">   return d1;</span><br><span class="line">&#125;</span><br><span class="line">return d2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="String-args-命令行参数"><a href="#String-args-命令行参数" class="headerlink" title="String[] args(命令行参数)"></a>String[] args(命令行参数)</h1><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**打印命令行参数的第零个*&#x2F;</span><br><span class="line">public class ArgsDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(args[0]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>命令行：</strong><br>其中java ArgsDemo是用于运行已编译好的class文件，后面的内容是命令行参数，以空格分隔。第零个是these。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ java ArgsDemo these are command line arguments</span><br><span class="line">these</span><br></pre></td></tr></table></figure><h1 id="Library"><a href="#Library" class="headerlink" title="Library"></a>Library</h1><h2 id="Library-Documentation-Example"><a href="#Library-Documentation-Example" class="headerlink" title="Library Documentation Example"></a>Library Documentation Example</h2><p><img src= "/img/loading.gif" data-lazy-src="https://s1.ax1x.com/2020/07/29/aZdYsP.png" alt="aZdYsP.png"></p><h1 id="Declaring-a-Variable"><a href="#Declaring-a-Variable" class="headerlink" title="Declaring a Variable"></a>Declaring a Variable</h1><p>声明一个int变量，生成32位的box<br>声明一个double变量，生成64位的box</p><h2 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h2><p>There are 8 primitive types in Java:<br>byte, short, int, long, float, double, boolean, char</p><p>Everything else, including arrays, is a reference type.<br>当声明一个reference type变量<br>These bits can be either set to:</p><ul><li>Null (all zeros).</li><li>The 64 bit “address” of a specific instance of that class (returned by new).</li></ul><p>The golden rule:<br>b = a copies the bits from a into b.<br>Passing parameters copies the bits.</p><h1 id="Declaration-and-Instantiation-of-Arrays"><a href="#Declaration-and-Instantiation-of-Arrays" class="headerlink" title="Declaration and Instantiation of Arrays"></a>Declaration and Instantiation of Arrays</h1><p><code>int[] x = new int[]&#123;0, 1, 2, 95, 4&#125;;</code></p><h1 id="SLList-单向列表"><a href="#SLList-单向列表" class="headerlink" title="SLList(单向列表)"></a>SLList(单向列表)</h1><h2 id="改进前"><a href="#改进前" class="headerlink" title="改进前"></a>改进前</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class IntList &#123;</span><br><span class="line">   public int first;</span><br><span class="line">   public IntList rest;</span><br><span class="line"> </span><br><span class="line">   public IntList(int f, IntList r) &#123;</span><br><span class="line">      first &#x3D; f;</span><br><span class="line">      rest &#x3D; r;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="改进后"><a href="#改进后" class="headerlink" title="改进后"></a>改进后</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public class SLList &#123;</span><br><span class="line">    public static class IntNode &#123;</span><br><span class="line">        public int item;</span><br><span class="line">        public IntNode next;</span><br><span class="line">        public IntNode(int i, IntNode n) &#123;</span><br><span class="line">            item &#x3D; i;</span><br><span class="line">            next &#x3D; n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private IntNode sentinel;</span><br><span class="line">    private int size;</span><br><span class="line"></span><br><span class="line">    public SLList() &#123;</span><br><span class="line">        sentinel &#x3D; new (63, null)</span><br><span class="line">        size &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public SLList(int x) &#123;</span><br><span class="line">        sentinel &#x3D; new IntNode(63, null);</span><br><span class="line">        sentinel.next &#x3D; new IntNode(x, null);</span><br><span class="line">        size &#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addFirst(int x) &#123;</span><br><span class="line">        sentinel.next &#x3D; new IntNode(x, sentinel.next);</span><br><span class="line">        size +&#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int getFirst() &#123;</span><br><span class="line">        return sentinel.next.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addLast(int x) &#123;</span><br><span class="line">        size +&#x3D; 1;</span><br><span class="line">        IntNode p &#x3D; sentinel;</span><br><span class="line">        while (p.next !&#x3D; null) &#123;</span><br><span class="line">           p &#x3D; p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p.next &#x3D; new IntNode(x, null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="改进步骤"><a href="#改进步骤" class="headerlink" title="改进步骤"></a>改进步骤</h2><table><thead><tr><th>Methods</th><th></th><th>Non-Obvious Improvements</th></tr></thead><tbody><tr><td>addFirst(int x)</td><td>#1</td><td>Rebranding: IntList → IntNode</td></tr><tr><td>getFirst</td><td>#2</td><td>Bureaucracy: SLList</td></tr><tr><td>size</td><td>#3</td><td>Access Control: public → private</td></tr><tr><td>addLast(int x)</td><td>#4</td><td>Nested Class: Bringing IntNode into SLList</td></tr><tr><td></td><td>#5</td><td>Caching: Saving size as an int.</td></tr><tr><td></td><td>#6</td><td>Generalizing: Adding a sentinel node to allow representation of the empty list.</td></tr></tbody></table><h2 id="第六步-哨兵节点"><a href="#第六步-哨兵节点" class="headerlink" title="第六步-哨兵节点"></a>第六步-哨兵节点</h2><p>使SLList有一个哨兵节点，而哨兵节点可以指向<code>null</code>或者<code>第一个节点</code></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>防止当列表为空时，无法用<code>first.method()</code>调用方法</p><h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><p>Inserting at the back of an SLList is much slower than the front.</p><h1 id="DLList-双向列表"><a href="#DLList-双向列表" class="headerlink" title="DLList(双向列表)"></a>DLList(双向列表)</h1><h2 id="改进一"><a href="#改进一" class="headerlink" title="改进一"></a>改进一</h2><p>增加<code>last</code>，指向最后一个节点</p><h3 id="缺陷-1"><a href="#缺陷-1" class="headerlink" title="缺陷"></a>缺陷</h3><p>对于倒数第二个节点来说还要重新遍历一遍</p><h2 id="改进二"><a href="#改进二" class="headerlink" title="改进二"></a>改进二</h2><p>使所有节点变成双向的</p><h2 id="改进三"><a href="#改进三" class="headerlink" title="改进三"></a>改进三</h2><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>增加一个指向<code>last</code>哨兵节点在开始时和指向<code>first</code>的哨兵节点互相指向<br>原因：last参数可能指向将要指向<code>first</code>的哨兵节点</p><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>使最后一个节点重新指向将要指向<code>first</code>节点的哨兵节点</p><h1 id="Generic-Lists-加入泛型"><a href="#Generic-Lists-加入泛型" class="headerlink" title="Generic Lists (加入泛型)"></a>Generic Lists (加入泛型)</h1><h2 id="ALList和DLList的缺陷"><a href="#ALList和DLList的缺陷" class="headerlink" title="ALList和DLList的缺陷"></a>ALList和DLList的缺陷</h2><p>One issue with our list classes: They only supports integers.</p><h2 id="泛型使用的法则"><a href="#泛型使用的法则" class="headerlink" title="泛型使用的法则"></a>泛型使用的法则</h2><h3 id="类编写"><a href="#类编写" class="headerlink" title="类编写"></a>类编写</h3><p>类名之后使用&lt;&gt;指定一次通用类型名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class DLList&lt;T&gt; &#123;</span><br><span class="line">    private IntNode sentinel;</span><br><span class="line">    private int size;</span><br><span class="line"></span><br><span class="line">    public class IntNode &#123;</span><br><span class="line">        public IntNode prev;</span><br><span class="line">        public T item;</span><br><span class="line">        public IntNode next;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="声明时使用"><a href="#声明时使用" class="headerlink" title="声明时使用"></a>声明时使用</h3><p>在声明时在&lt;&gt;中指定一次特定的所需类型，并在实例化时使用空的&lt;&gt;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DLList&lt;String&gt; d2 &#x3D; new DLList&lt;&gt;(&quot;hello&quot;);</span><br><span class="line">d2.addLast(&quot;world&quot;);</span><br></pre></td></tr></table></figure><h3 id="实例化一个普通的基本类型"><a href="#实例化一个普通的基本类型" class="headerlink" title="实例化一个普通的基本类型"></a>实例化一个普通的基本类型</h3><p>使用Integer，Double，Character，Boolean，Long，Short，Byte，或Float。</p><h1 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h1><p>Three valid notations:<br>x = new int[3];<br>y = new int[]{1, 2, 3, 4, 5};<br>int[] z = {9, 10, 11, 12, 13};</p><h2 id="Two-ways-to-copy-arrays"><a href="#Two-ways-to-copy-arrays" class="headerlink" title="Two ways to copy arrays"></a>Two ways to copy arrays</h2><ul><li>Item by item using a loop.</li><li>Using <code>System.arraycopy(b, 0, x, 3, 2)</code> Takes 5 parameters:<ul><li>Source array</li><li>Start position in source</li><li>Target array</li><li>Start position in target</li><li>Number to copy </li></ul></li></ul><h1 id="2D-arrays-二维数组"><a href="#2D-arrays-二维数组" class="headerlink" title="2D arrays(二维数组)"></a>2D arrays(二维数组)</h1><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int[][] x &#x3D; new int[3][];</span><br><span class="line">\\这将为x创建一个64bits的内存盒用于存储地址，和三个64bits的内存盒用于存储指向下一层数组（长度未确定）的地址。</span><br><span class="line">int[][] y &#x3D; new int [][]&#123;&#123;1&#125;, &#123;1, 1&#125;, &#123;1, 2, 1&#125;, &#123;1, 3, 3, 1&#125;&#125;;;</span><br><span class="line">int[][] z &#x3D; &#123;&#123;1&#125;, &#123;1, 1&#125;, &#123;1, 2, 1&#125;, &#123;1, 3, 3, 1&#125;&#125;;;</span><br></pre></td></tr></table></figure><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int[][] pascalsTriangle;</span><br><span class="line">pascalsTriangle &#x3D; new int[4][];</span><br><span class="line">int[] rowZero &#x3D; pascalsTriangle[0];</span><br><span class="line"></span><br><span class="line">pascalsTriangle[0] &#x3D; new int[]&#123;1&#125;;</span><br><span class="line">pascalsTriangle[1] &#x3D; new int[]&#123;1, 1&#125;;</span><br><span class="line">pascalsTriangle[2] &#x3D; new int[]&#123;1, 2, 1&#125;;</span><br><span class="line">pascalsTriangle[3] &#x3D; new int[]&#123;1, 3, 3, 1&#125;;</span><br><span class="line">int[] rowTwo &#x3D; pascalsTriangle[2];</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>int[][] x = new int[n][];</code><br>声明一个叫x的数组，数组的<code>size</code>为n，每个位置可以指向一个int数组</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>数组中所存贮的数据类型必须一致</p><h1 id="Naive-Array-Lists-数组列表"><a href="#Naive-Array-Lists-数组列表" class="headerlink" title="Naive Array Lists(数组列表)"></a>Naive Array Lists(数组列表)</h1><h2 id="使用数组列表需要注意的事项"><a href="#使用数组列表需要注意的事项" class="headerlink" title="使用数组列表需要注意的事项"></a>使用数组列表需要注意的事项</h2><ul><li>he position of the next item to be inserted is always size.</li><li>size is always the number of items in the AList.</li><li>The last item in the list is always in position size - 1.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class AList &#123;</span><br><span class="line">  private int[] items;    </span><br><span class="line">  private int size;</span><br><span class="line"> </span><br><span class="line">  public AList() &#123;</span><br><span class="line">    items &#x3D; new int[100];  size &#x3D; 0;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  public void addLast(int x) &#123;</span><br><span class="line">    items[size] &#x3D; x;</span><br><span class="line">    size +&#x3D; 1;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  public int getLast() &#123;</span><br><span class="line">    return items[size - 1];</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  public int get(int i) &#123;</span><br><span class="line">    return items[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public int size() &#123;</span><br><span class="line">    return size;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public int removeLast() &#123;</span><br><span class="line">  int returnItem &#x3D; items[size - 1];</span><br><span class="line">  items[size - 1] &#x3D; 0;</span><br><span class="line">  size -&#x3D; 1;  </span><br><span class="line">  return returnItem;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="resizing"><a href="#resizing" class="headerlink" title="resizing"></a>resizing</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void resize(int capacity) &#123;</span><br><span class="line">  int[] a &#x3D; new int[capacity];</span><br><span class="line">  System.arraycopy(items, 0, a, 0, size);</span><br><span class="line">  items &#x3D; a;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public void addLast(int x) &#123;</span><br><span class="line">  if (size &#x3D;&#x3D; items.length) &#123;</span><br><span class="line">resize(size + 1);</span><br><span class="line">  &#125;</span><br><span class="line">  items[size] &#x3D; x;</span><br><span class="line">  size +&#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="改进使得节省内存（减少resize的次数）"><a href="#改进使得节省内存（减少resize的次数）" class="headerlink" title="改进使得节省内存（减少resize的次数）"></a>改进使得节省内存（减少resize的次数）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void addLast(int x) &#123;</span><br><span class="line">  if (size &#x3D;&#x3D; items.length) &#123;</span><br><span class="line">resize(size * RFACTOR);</span><br><span class="line">  &#125;</span><br><span class="line">  items[size] &#x3D; x;</span><br><span class="line">  size +&#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="改进-优化内存"><a href="#改进-优化内存" class="headerlink" title="改进-优化内存"></a>改进-优化内存</h3><ul><li>Define the “usage ratio” R = size / items.length;</li><li>Typical solution: Half array size when R &lt; 0.25.</li></ul><h3 id="泛型数组列表"><a href="#泛型数组列表" class="headerlink" title="泛型数组列表"></a>泛型数组列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class AList&lt;Glorp&gt; &#123;</span><br><span class="line">  private Glorp[] items;    </span><br><span class="line">  private int size;</span><br><span class="line"> </span><br><span class="line">  public AList() &#123;</span><br><span class="line">    items &#x3D; (Glorp []) new Object[8];  </span><br><span class="line">    size &#x3D; 0;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  private void resize(int cap) &#123;</span><br><span class="line">    Glorp[] a &#x3D; (Glorp []) new Object[cap];</span><br><span class="line">    System.arraycopy(items, 0, </span><br><span class="line">                     a, 0, size);</span><br><span class="line">    items &#x3D; a;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Glorp get(int i) &#123;</span><br><span class="line">    return items[i];</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="deleteback-方法"><a href="#deleteback-方法" class="headerlink" title="deleteback 方法"></a>deleteback 方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public Glorp deleteBack() &#123;</span><br><span class="line">  Glorp returnItem &#x3D; getBack();</span><br><span class="line">  items[size - 1] &#x3D; null;</span><br><span class="line">  size -&#x3D; 1;  </span><br><span class="line">  return returnItem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：<br>Java only destroys unwanted objects when the last reference has been lost.</strong></p><ul><li><strong>新名词：</strong><code>loiter</code><ul><li>Keeping references to unneeded objects is sometimes called loitering.</li><li>Save memory. Don’t loiter.</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git命令</title>
      <link href="posts/b6ef4fe0/"/>
      <url>posts/b6ef4fe0/</url>
      
        <content type="html"><![CDATA[<p>#本地修改提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;&quot;</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>##其他类型git add：</p><ul><li>git add -A  提交所有变化</li><li>git add -u  提交被修改(modified)和被删除(deleted)文件，不包括新文件(new)</li><li>git add .  提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件</li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo Title记录</title>
      <link href="posts/68ae36ec/"/>
      <url>posts/68ae36ec/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">title: 文章加密</span><br><span class="line">date: 2019-01-04T22:20:13.000Z</span><br><span class="line">category: 教程</span><br><span class="line">tags:</span><br><span class="line">  - 博客</span><br><span class="line">  - Hexo</span><br><span class="line">keywords: 博客文章密码</span><br><span class="line">password: TloveY</span><br><span class="line">abstract: 密码：TloveY</span><br><span class="line">description: Github的一些常用指令</span><br><span class="line">cover: https:&#x2F;&#x2F;s1.ax1x.com&#x2F;2020&#x2F;07&#x2F;26&#x2F;aCIWz4.png</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Diary</title>
      <link href="posts/50bac2e6/"/>
      <url>posts/50bac2e6/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="963a79efbda65eec999f26d7adc824cf98d4c8ea36805cff353df95aff502d6f">b81a116c6622914e479a90f72160ea1afae9fae62730f9e79c9bbe07a4446c058809f1aecf0e7b78f5b778ad3af196f6</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Diary </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
